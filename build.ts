import webpack from 'webpack';
import type {Configuration as WebpackConfiguration} from 'webpack';
import type {Configuration as WebpackDevServerConfiguration} from 'webpack-dev-server';
import path from 'path';

import {VanillaExtractPlugin} from '@vanilla-extract/webpack-plugin';
import MiniCssExtractPlugin from 'mini-css-extract-plugin';

const ROOT_PATH = path.resolve(__dirname);

const config: WebpackConfiguration & WebpackDevServerConfiguration = {
  mode: 'production',
  entry: path.join(ROOT_PATH, 'src', 'index.ts'),
  output: {
    environment: {
      arrowFunction: false,
      const: false,
      destructuring: false,
      forOf: false
    },
    filename: 'index.system.js',
    chunkFilename: 'chunk.[name].js',
    path: path.resolve(__dirname, 'dist'),
    libraryTarget: 'system'
  },
  watch: false,
  devServer: {
    allowedHosts: 'all',
    port: 9091,
    hot: true,
    headers: { 'Access-Control-Allow-Origin': '*' },
    server: { type: 'http', options: {} }
  },
  optimization: {
    chunkIds: 'named',
    minimize: true,
    sideEffects: true,
    splitChunks: { chunks: 'initial', cacheGroups: {} }
  },
  devtool: 'source-map',
  plugins: [
    new VanillaExtractPlugin(),
    new MiniCssExtractPlugin({
        filename: 'style.css',
        runtime: true,
    })
  ],
  // resolve: {},
  resolve: {
      extensions: ['.ts', '.tsx', '.js'],
  },
  module: {
    rules: [
      {
        test: /\.(tsx?|js)?$/,
        exclude: /node_modules\//,
        loader: 'ts-loader',
        options: {
            transpileOnly: false,
        },
      },
      {
        test: /\.vanilla\.css$/i, // Targets only CSS files generated by vanilla-extract
        use: [
          MiniCssExtractPlugin.loader,
          {
            loader: require.resolve('css-loader'),
            options: {
              url: false // Required as image imports should be handled via JS/TS import statements
            }
          }
        ]
      }
    ]
  },
  // performance: {},
};

webpack(config, (err, stats) => {
    if (err || stats?.hasErrors()) {
        const error = err ?? stats?.compilation.errors[0];

        console.log(['Build failed'].join('\n'));
        console.error(error?.message);

        return process.exit(1);
    }

    const time = stats?.toJson().time;
    const buildMessage = [`Build complete\nWhen: ${new Date().toLocaleString()}`];

    if (time) buildMessage.push(`Duration: ${time / 1000}s`);

    console.log(buildMessage.join('\n'));
});
